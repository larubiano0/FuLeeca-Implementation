import galois
import hashlib
import numpy as np
import utils

def signature_verification(v, n, G_pub, m, w_sig, sec_level, salt, p):
    """
    Verify a signature vector against the public key and message.
    
    Parameters
    ----------
    v : galois.FieldArray
        The signature vector to be verified.
    n : int
        The code length.
    G_pub : galois.FieldArray
        The public key matrix.
    m : bytes
        The original message that was signed.
    w_sig : int
        The target Lee weight per codeword.
    sec_level : int
        Security level in bits.
    salt : bytes
        Random salt used in the signature generation.
    p : int
        The size of the finite field, which is a prime number.

    Returns
    -------
    Accept : bool
        True if the signature is valid, False otherwise.
    """
    Hash = hashlib.sha3_512()
    Hash.update(m) 
    m_prime = Hash.digest()[:(2 * sec_level)//8] # Hash the message and truncate to security level
    CSPRNG = hashlib.shake_256()
    CSPRNG.update(m_prime + salt)
    c = np.unpackbits(np.frombuffer(CSPRNG.digest(n//8 + 1), dtype=np.uint8))[:n] # Numpy array of shape (n,) with entries in {0,1}, the +1 and the slicing is to ensure we have enough bits
    c = [((-1)**int(bit))%p for bit in c] # Convert to {+1, -1}

    r = np.linalg.matrix_rank(G_pub)
    r_aug = np.linalg.matrix_rank(np.vstack((G_pub, v)))
    in_code = (r_aug == r) # Check if v is in the code generated by G_pub

    return in_code and (utils._Lee_weight(v, p) <= w_sig) and (utils.LMP(v, c, p) >= sec_level + 64)

